---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
```

```{python}
import numpy as np

N = int(input("Antal dronninger der skal løses: \n"))
N = 4
grid = np.zeros([N,N],dtype=int)
grid=grid.tolist()
print("Går fra grid til list: " ,grid)

def possible(grid,y,x): #is it possible to place a queen into y,x?

    l=len(grid) #how big is our grid?
    #print("Længden på vores problemet ", l)
    
    for i in range(l): #check for queens on row y
        if grid[y][i]==1: #if exist return false
            return False
    for i in range(l):  #check for queens on column x
        if grid[i][x]==1: #if exists return 0
            return False
        
    for i in range(l): #loop through all rows
        for j in range(l): #and columns
            if grid[i][j]==1: #if there is a queen
                if abs(i - y) == abs(j - x): #and if there is another on a diagonal
                    return False #return false
    return True #if every check clears, we can return true

def solve(grid):
    
    l=len(grid) #length of our grid  
    
    for y in range(l): #for every row
        for x in range(l): #for every column
            if grid[y][x]==0: # we can place if there is no queen in given position
                if possible(grid,y,x): #if empty, check if we can place a queen
                    grid[y][x]=1 #if we can, then place it
                    solve(grid) #pass grid for recursive solution
                    #if we end up here, means we searched through all children branches
                    if sum(sum(a) for a in grid)==l: #if there are 8 queens
                        return grid #we are successful so return
                    grid[y][x]=0 #remove the previous placed queen


    return grid #means we searched the space, we can return our result
```



# Lecture 9 [Recursion and iteration]

## Exercise 9.1 (bitonic minimum)

We call a list L=[x1, ..., xn] bitonic, if there exists a k, 1<k<n, such that x1 > x2 > ··· > xk-1 > xk < xk+1 < ··· < xn, i.e. xk is the minimum of the list. Write a method bitonic_min that given a list, returns the minimum of the list. Your implementation should use binary search (i.e. you cannot use the Python builtin min function).
Example: bitonic_min([10,7,4,2,3,5,9,11]) should return 2.

```{python}
def bitonic_min(x):
  minimum = x[0]
  for i in x[1:]:
    if i < minimum:
      minimum = i
  return minimum
print("Output af opgave 9.1 :", bitonic_min([10,7,4,2,3,5,9,11]) )
```

## Exercise 9.2 (print tree)

Assume we represent a tree by a recursive tuple, consisting of the name of the root followed by one recursive tuple for each of the children. Note that all nodes have a label (not only the leaves), and that a node with k children is represented by a tuple of length k+1. Write a program that prints the tree with one label per line and with appropriate indentation, like below.
Example: ('root', ('node 1',), ('node 2', ('node 2.1',), ('node 2.2',)), ('node 3',)) should be printed as

--root
  |--node 1
  |--node 2
  |  |--node 2.1
  |  |--node 2.2
  |--node 3
Hint. Write a recursive method and pass a string as an argument with the prefix to be printed in front of all lines generated by the recursive call.

```{python}
test = ('root', ('node 1'))
type(test)

def root_print(L, indentation = 2):
  prefix = '-' * indentation
  if isinstance(L, tuple):
    s = ''
    s += prefix
    children = []
    for child
```

## Exercise 9.3 (maze path)
In this exercise you should code a recursive maze solver, that does a recursive search for the path from "A" to "B" in a rectangular maze. The program should read from input a maze represented by first a single line containing two numbers, the number of rows n and columns m of the maze, followed by n rows each containing a string of length m representing the maze, where "#" is a blocked cell, "A" denotes the start cell, "B" the end cell, and "." a free cell ("A" and "B" are also free cells). Given a free cell one can move to an adjacent free cell horizontally and vertically but not diagonally. An example input:


The program should output the string "no path" if there exist no path from A to B in the maze. If there exists a path, a solution should be printed with "x" marking the path from A to B. A possible solution to the above maze is:

Note: In the lecture the solution only identified if there was a path from A to B.
Hint: One solution is to modify the solution from the lecture, and only make recursive calls when a solution has not been found yet, and to update the maze before returning from a recursive call. Use print('\n'.join(maze)) to print the maze.


## Exercise 9.4* (deepcopy)
In this exercise you should implement your own version of the deepcopy operation from the module copy for lists. Recall that when copying a list L using L.copy(), only a copy of the list will be created. The new list will point to the same elements as L, which might cause unexpected behaviour when these are mutable structures, like recursive lists. The operation copy.deepcopy also makes a recursive copy of such recursive lists.

The difference is illustrated by the following code:

import copy
L1 = [[1], [2]]
L2 = L1.copy()
L3 = copy.deepcopy(L1)
L1[0][0] = 3
print(f'{L1=} {L2=} {L3=}')
that prints

L1=[[3], [2]] L2=[[3], [2]] L3=[[1], [2]]
Your task is to implement your own function deepcopy that creates such a recursive deep copy of recursive lists.

Hint: Recall that the same list can be refered to multiple times, and that there can be cyclic references among the lists, like in the following example.

L = [[1], [2], [3]]
L[2] = L
To handle the copying of such recursive structures it is important to know that each list L has a unique id id(L). E.g.
print(f'{L=} {id(L)=} {id(L[0])=} {id(L[1])=} {id(L[2])=}')
could print
L=[[1], [2], [...]] id(L)=2373651524288 id(L[0])=2373623114048 id(L[1])=2373623104832 id(L[2])=2373651524288
Note that L and L[2] have identical ids, since they refer to the same list.

Example:

L1 = [[1], [2], [3]]
L2 = deepcopy(L1)
L1[1] = L1[0]
L1[2][0] = L1
L3 = deepcopy(L1)
L3[0][0] = 7
print(f'{L1=} {L2=} {L3=}')
should print
L1=[[1], [1], [[...]]] L2=[[1], [2], [3]] L3=[[7], [7], [[...]]]


# Afleveringer

## Aflevering 5 

```{python}
print ("Enter the number of queens")
N = int(input())

#chessboard
#NxN matrix with all elements 0
board = [[0]*N for _ in range(N)]

def is_attack(i, j):
    #checking if there is a queen in row or column
    for k in range(0,N):
        if board[i][k]==1 or board[k][j]==1:
            return True
    #checking diagonals
    for k in range(0,N):
        for l in range(0,N):
            if (k+l==i+j) or (k-l==i-j):
                if board[k][l]==1:
                    return True
    return False

def N_queen(n):
    #if n is 0, solution found
    if n==0:
        return True
    for i in range(0,N):
        for j in range(0,N):
            '''checking if we can place a queen here or not
            queen will not be placed if the place is being attacked
            or already occupied'''
            if (not(is_attack(i,j))) and (board[i][j]!=1):
                board[i][j] = 1
                #recursion
                #wether we can put the next queen with this arrangment or not
                if N_queen(n-1)==True:
                    return True
                board[i][j] = 0

    return False

N_queen(N)
for i in board:
    print (i)
```

