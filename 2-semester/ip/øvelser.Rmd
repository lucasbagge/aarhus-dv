---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
```

## Lecture 9 [Recursion and iteration]

### Exercise 9.1 (bitonic minimum)

We call a list L=[x1, ..., xn] bitonic, if there exists a k, 1<k<n, such that x1 > x2 > ··· > xk-1 > xk < xk+1 < ··· < xn, i.e. xk is the minimum of the list. Write a method bitonic_min that given a list, returns the minimum of the list. Your implementation should use binary search (i.e. you cannot use the Python builtin min function).
Example: bitonic_min([10,7,4,2,3,5,9,11]) should return 2.

```{python}
def bitonic_min(x):
  minimum = x[0]
  for i in x[1:]:
    if i < minimum:
      minimum = i
  return minimum
print("Output af opgave 9.1 :", bitonic_min([10,7,4,2,3,5,9,11]) )
```

### Exercise 9.2 (print tree)

Assume we represent a tree by a recursive tuple, consisting of the name of the root followed by one recursive tuple for each of the children. Note that all nodes have a label (not only the leaves), and that a node with k children is represented by a tuple of length k+1. Write a program that prints the tree with one label per line and with appropriate indentation, like below.
Example: ('root', ('node 1',), ('node 2', ('node 2.1',), ('node 2.2',)), ('node 3',)) should be printed as

--root
  |--node 1
  |--node 2
  |  |--node 2.1
  |  |--node 2.2
  |--node 3
Hint. Write a recursive method and pass a string as an argument with the prefix to be printed in front of all lines generated by the recursive call.

```{python}
test = ('root', ('node 1'))
type(test)

def root_print(L, indentation = 2):
  prefix = '-' * indentation
  if isinstance(L, tuple):
    s = ''
    s += prefix
    children = []
    for child
```

### Exercise 9.3 (maze path)
In this exercise you should code a recursive maze solver, that does a recursive search for the path from "A" to "B" in a rectangular maze. The program should read from input a maze represented by first a single line containing two numbers, the number of rows n and columns m of the maze, followed by n rows each containing a string of length m representing the maze, where "#" is a blocked cell, "A" denotes the start cell, "B" the end cell, and "." a free cell ("A" and "B" are also free cells). Given a free cell one can move to an adjacent free cell horizontally and vertically but not diagonally. An example input:


The program should output the string "no path" if there exist no path from A to B in the maze. If there exists a path, a solution should be printed with "x" marking the path from A to B. A possible solution to the above maze is:

Note: In the lecture the solution only identified if there was a path from A to B.
Hint: One solution is to modify the solution from the lecture, and only make recursive calls when a solution has not been found yet, and to update the maze before returning from a recursive call. Use print('\n'.join(maze)) to print the maze.


### Exercise 9.4* (deepcopy)
In this exercise you should implement your own version of the deepcopy operation from the module copy for lists. Recall that when copying a list L using L.copy(), only a copy of the list will be created. The new list will point to the same elements as L, which might cause unexpected behaviour when these are mutable structures, like recursive lists. The operation copy.deepcopy also makes a recursive copy of such recursive lists.

The difference is illustrated by the following code:

import copy
L1 = [[1], [2]]
L2 = L1.copy()
L3 = copy.deepcopy(L1)
L1[0][0] = 3
print(f'{L1=} {L2=} {L3=}')
that prints

L1=[[3], [2]] L2=[[3], [2]] L3=[[1], [2]]
Your task is to implement your own function deepcopy that creates such a recursive deep copy of recursive lists.

Hint: Recall that the same list can be refered to multiple times, and that there can be cyclic references among the lists, like in the following example.

L = [[1], [2], [3]]
L[2] = L
To handle the copying of such recursive structures it is important to know that each list L has a unique id id(L). E.g.
print(f'{L=} {id(L)=} {id(L[0])=} {id(L[1])=} {id(L[2])=}')
could print
L=[[1], [2], [...]] id(L)=2373651524288 id(L[0])=2373623114048 id(L[1])=2373623104832 id(L[2])=2373651524288
Note that L and L[2] have identical ids, since they refer to the same list.

Example:

L1 = [[1], [2], [3]]
L2 = deepcopy(L1)
L1[1] = L1[0]
L1[2][0] = L1
L3 = deepcopy(L1)
L3[0][0] = 7
print(f'{L1=} {L2=} {L3=}')
should print
L1=[[1], [1], [[...]]] L2=[[1], [2], [3]] L3=[[7], [7], [[...]]]


## Lecture 10 (Functions as objects)

### Exercise 10.1 (foldr)

In this exercise the goal is to make an implementation of foldr. Python's reduce function is often called foldl in other programming languages, and given a function f and a list [x1, ..., xn] computes f(···f(f(x1,x2),x3)···,xn). The function foldr should instead compute f(x1,(···f(xn-2,f(xn-1,xn))···)). This function does not appear in the Python standard library but is standard in other programming languages, in particular functional programming languages like Haskell and ML. The difference between folding left and right is illustrated by applying the power function to the list [2, 2, 2, 2], where ((2**2)**2)**2 = 256 whereas 2**(2**(2**2)) = 65536.

```{python}
import functools
foldl = functools.reduce

def foldr(f, L):
  return functools.reduce()


print(foldl(lambda x,y: x**y, [2,2,2,2]))   # prints 256
print(foldr(lambda x,y: x**y, [2,2,2,2]))   # should print 65536
print(foldr(lambda x,y: x**y, [2,2,2,2,2])) # value with 19729 digits
```



Note. You can implement foldr both with a loop and recursively.

### Exercise 10.2 (my_map)

In this exercise the goal is make your own implementation of Python's builtin map function.

#### a) Make a function my_map that takes two arguments, a function f and a list [x1,...,xn], and returns the list [f(x1),...,f(xn)].
Example: my_map(lambda x: x ** 3, [3, 2, 4])) should return [27, 8, 64].

```{python}
import inspect
lines = inspect.getsource(map)
print(lines)
```

```{python}
def my_map(lst):
  for i in lst:
    lst += lst
  return lst
my_map()([1,2])
```



#### b) Make a function my_map_k that as arguments takes a function f and k lists L1,...,Lk, for an arbitrary k ≥ 1, and returns the list [f(L1[0],...,Lk[0]),...,f(L1[n-1],...,Lk[n-1])], where n is the length of the shortest Li list.

Hint. Use Python's * notation to handle an arbitrary number of lists as arguments.
Example: my_map_k(lambda x, y, z: x*y*z, [3, 2, 5], [2, 7, 9], [1, 2]) should return [6, 28].
Note. Your solution should not use the builtin map function.


### Exercise 10.3 (string sorting)


Write a function str_sort that sorts a list of strings, such that the strings are sorted with respect to the number of distinct letters ('a' - 'z') there are in the strings. Strings with an equal number of distinct letters after converting to lower case should apper in alphabetical order.

Example: str_sort(['AHA', 'Oasis', 'ABBA', 'Beatles', 'AC/DC', 'B. B. King', 'Bangles', 'Alan Parsons']) should return ['ABBA', 'AHA', 'AC/DC', 'Oasis', 'B. B. King', 'Beatles', 'Alan Parsons', 'Bangles'].

Hint. Use len(set(X)) to find the number of different elements in a list X.

```{python}
def str_sort(x):
  

str_sort(['AHA', 'Oasis', 'ABBA', 'Beatles', 'AC/DC', 'B. B. King', 'Bangles', 'Alan Parsons']) 
```



## Lecture 11 (Object oriented programming)

### example https://www.geeksforgeeks.org/__init__-in-python/

```{python}
class Person:
  def __init__(self, name):
    self.name = name
    
  def say_hi(self):
    print('Hello, my name is', self.name)
p = Person('Nik')
p.say_hi()
```

__init__ betyder vi begynder på vores objekt. Således vil vi gå tilbage og begynde
klassen. 

### Exercise 11.1 (PersonReader)

Implement a class PersonReader supporting the following methods:

input() asks the user for the name and year of birth of a person at shell prompt (using the builtin input function).
__str__ that returns the string "name (year)" (e.g. to be used by the print method when applied to a PersonReader).

```{python}

'''
implemt a class PersonReaer supporting the following method:
  - input() asks the user for the name an year
  - __str__ tghat returtun the sting
'''
class PersonReader:
  
  def __init__(self, name = "Super", year = 2016):
    self.name = name
    self.year = year
    
  def input(self):
    self.name = input("input name: ")
    self.year = int(input("input year: "))
    
  def __str__(self):
    return ("%s (%d)" %(self.name, self.year))
  
test = PersonReader()
print(test)
```

```{python}
test = PersonReader()
print(person)

```



### Exercise 11.2 (Stopwatch)

Implement a class Stopwatch that creates a timer that can measure the total between calls to the methods start and stop. The methods that should be supported are:

start() start the stopwatch.
stop() stop the stopwatch.
lap() record the current time as a laptime.
total_time() return the time between last start and subsequent call to stop. If the stopwatch is still running, return time since last call to start and the current time.
lap_times() return a list of the lap times. If there have been k calls to lap between the calls to start and stop, it should return a list of the k+1 lap times. The sum of the lap_times should equal the time of total_time.
It can be assumed that start is the first method that will be called.

Hint. Use the method time in module time, i.e. add from time import time to your code. The function time() returns the number of seconds since, typically, January 1, 1970, 00:00:00.

```{python}
from time import time

class Stopwatch:
    def __init__(self):
        self.running = False

    def start(self):
        if not self.running:
            self.running = True
            self.start_time = time()
            self.laps = []
    
    def stop(self):
        self.end_time = time()
        self.running = False

    def lap(self):
        self.laps.append(time())

    def total_time(self):
        if self.running:
            end = time()
        else:
            end = self.end_time
        return end - self.start_time

    def lap_times(self):
        if self.running:
            end = tim()
        else:
            end = self.end_time
        return [end - start for end, start in 
                zip(self.laps + [end], [self.start_time] + self.laps)]

ur = Stopwatch()

ur.start()
ur.lap()
ur.lap()
ur.lap()
ur.lap()
ur.stop() 
ur.lap_times()
```


### Exercise 11.3 (2D vector)

In this exercise you should implement a class Vector for storing 2D vectors of the form <x, y>. The class should have the following methods:

A constructor __init__ where it is possible to create a new vector using Vector(x,y).
length() returning the length of the vector, i.e. sqrt(x2 + y2).
Hint. from math import sqrt
add(other_vector) return a new vector that is the result of adding two vectors.
Redefine "+" so that vector1 + vector2 returns a new vector that is the sum of the two vectors (i.e. define __add__).
mult(factor), where factor is an int or float, should return a new vector <x*factor, y*factor>.
dot(vector) should return the dot product with another vector, i.e. x*vector.x + y*vector.y.
Define the "*" operator so that vector * number returns vector.mul(number) whereas vector1 * vector2 returns the dot product of the two vectors (i.e. define __mul__).
Define __rmul__ so that it possible to write number * vector. The result should be the same as vector * number.
Define __str__ to return the string "<x, y>" where x and y are the coordinates of the vector.

## Lecture 12 (Class hierarchies)

### Exercise 12.1 (geometric shapes)

Make a class Shape that represent an abstract geometric shape. Conrete shapes, like circles, axis-aligned rectangles, and triangles should be defined as subclasses of Shape. The class Shape should only define a method fatness that depends on methods area and perimeter that should be defined in subclasses:

fatness() return 4·π·area / perimeter2.
Subclasses should implement the following methods (but note the method fatness):

__init__ initialize the geometric object. The arguments to __init__ will depend on the geometric shape.
__str__ return a string describing the object, e.g. Circle(radius=3, center=(4,5))
area() return the area of a geometric object.
perimeter() return the length of the perimeter of the geometric object.
contains(x, y) returns if the point (x, y) is contained within the shape.
Create classes Circle, Rectangle, and Triangle, each inheriting from class Shape. Implementing class Triangle is optional (the methods area and contains require some amount of math, with solutions easily to find on the internet). For each subclass implement the methods __int__, __str__, area, perimeter, and contains.

It should be possible to create instances of the geometric opjects (calling __init__) as follows:

Circle(radius, center_x, center_y)
Rectangle(min_x, max_x, min_y, max_y)
Triangle(x0, y0, x1, y1, x2, y2)
Example:

> shapes = [Rectangle(0,10,0,1), Circle(4,1,4), Triangle(1,2,1,4,2,3)]
> [str(s) for s in shapes]
['Rectangle((0, 0), (10, 1))', 'Circle(radius=4, center=(1, 4))', 'Triangle((1, 2), (1, 4), (2, 3))']
> [s.area() for s in shapes]
[10, 50.26548245743669, 1.0]
> [s.perimeter() for s in shapes]
[22, 25.132741228718345, 4.82842712474619]
> [s.fatness() for s in shapes]
[0.25963575649502424, 1.0, 0.5390120844526473]
> [s.contains(1,1) for s in shapes]
[True, True, False]


## Exceptions funktion

- kan i stedet for if bruge try og exception.

```{python}
try:
  result = numerator / denominator
except ZeroDevisionError:
  print('cannot')
  continue
```

- hvorfor er det mere efficient eller bedre end if statement.
- definerer forskellige except som er typer af fejl. f.eks. ValueError.
- Brug ctrl + c så stopper den, her skal vi skriv

```{python}
try:
  x = 0
  while True:
    x = x + 1
except KeyboardInterrupt:
  pass
```

- i pdf oversigt over brugen og variaioner. 

## filer i python

- kan åbne filr

```{python}
f = open('read')
for line in f:
  print(">", line[:-1])
f.clost()
```

- hvor der er nogle forskellige varianter af metoden. 
- Du kan også bruge `FileNotFoundError` hvis nogle filer ikke findes. 

```{python}
try:
  f = open()
except 
```

- `with` er et keyword der tillader at skabe en **context manager** for filer. Den lukker filen og åbner implicit.

- brug modul os.

```{python}
import os.path

name = input("")
if os.path.isfile(name)
```

- Der er også modulet `sys` som har hvordan man håndter filer. 

```{python}
import sys
sys.stdin
sys.stdout
sys.stderr
```


- pep8 on exceptions.
- Se på sudoku løsning


## testing

- bliv bedre til dokumentation og fejl. 
- vi starter med en ide om hvordan vi vil løse det. SÅ går vi i gang med at kode og en implementation af det. så kommr der en og kører det. Design fase, udvikling og brugsfase.
- i udvikling har vi fix bug, test og find bug. 
- en god kode er den er strukturet, dokumenteret, kommentar og følger kodnings standard såsom pep8. 

```{python}
# test

def f(depth):
  if depth > 100:
    print("fejl")
    raise SystemtExit
  f(depth + 1)
  
f(0)
```

- kan også brue assert som  som check om en udtryk er sand hvis ikke vil den rejse en AssertionError.
- Kan og tilføje en kommentar til assertion. 
- det gør program langsom.
- en **dicstring** er en text som forklarer funktionen. 
- Test et program er vigtig. der er en type kaldet black box testing. 
- unitest. et module hvor vi laver klasser til at lave funktioner til hvert teest. 
- Man kan debugge. I shell kan man vælge debug og stack viewer for at finde fejl. Kan bruges når vi kører noget recursivt. 

```{python}
def f(n):
  return 1 / n + f(n+1)
```

```{python}
f(5)
```


- **mypy** typer tilføjelser til program og se om den gør hvad vif orventer.

```{python}
print("start")
print(42 + "abc")
print("end")
```


- mypy analyser programmet inden det kører

```{python}
import mypy
```


## Lecture 13 (Exceptions and file input/output)

### Exercise 13.1 (sum of two integers)

Write a program that as input takes a single line with two integers and outputs their sum. A valid input line consist of two integers separated by one or more white spaces. Input can be preceded and followed by white spaces. The program should repeat asking for input until a valid input is given.

Input two integers, separated by space: 2 a
invalid input
Input two integers, separated by space: 2 3.0
invalid input
Input two integers, separated by space: 2 3
Sum = 5
  
Hint. Use exceptions to handle illegal input.

```{python}
while True:
  try:
    x, y = input("input ").split(" ")
    print(f'sum = {int(x) + int(y)}')
  except Exception:
    print("invaldi")
    continue
  break
```


### Exercise 13.2 (transposing)

In this excercise we assume that a file stores a matrix, where the rows are stored in consecutive lines in the file, and where column values are separated by ';' . Your task is to make a program that writes the transposed matrix to another file - see example below.

Input

1;2;3;4
5;6;7;8
9;10;11;12
Output

1;5;9
2;6;10
3;7;11
4;8;12
The program should ask the user for the name of an input file and the name of an output file, read the matrix in the input file, and write the transposed matrix to the output file.

Your solution should handle the following potential errors.

If input file does not exist, report this to the user and start over.
If output file already exists, warn the user, and ask the user to confirm to overwrite the existing file.
If the lines in the input file have a different number of values, i.e. the input is not a valid matrix, report this to the user, and start over without writting any output.
Hint. Use the string method split to split an input line into a list of values.

```{python}

import os.path

while True:
  try:
    matrix = input("name of the input file: ")
    f = 
```


### Exercise 13.3 (grade statistics)

In this exercise you should write a program that reads two files: one respectively containing the names and address of students, and one containing exam results. The output of the program should be a summary of the exam performances.

The student list is stored in a file, with one student per line, consisting of the three fields, separated by ';' : the unique student id, name and address.

107;Donald Duck;Duck Steet 13, Duckburg
243;Mickey Mouse;Mouse Street 42, Duckburg
465;Goofy;Clumsy Road 7, Duckburg
777;Scrooge McDuck;Money Street 1, Duckburg
The second file contains the list of exam results, consisting of a line per grade giving, consisting of a triple, with values separated by ';' : student id, course name, and grade.

107;Programming;10
107;Mathematics;8
107;Computability;7
243;Programming;10
243;Computer forensic;10
243;Computability;9
465;Mathematics;6
The program should print a summary like the below:

<!-- Student id Name            Average #Courses -->
<!-- =========================================== -->
<!-- 107        Donald Duck        8.33        3 -->
<!-- 243        Mickey Mouse       9.67        3 -->
<!-- 465        Goofy              6.00        1 -->
<!-- 777        Scrooge McDuck     0.00        0 -->


```{python}
std = open("13.4-file1.txt")
exm = open("13.4-file2.txt")

studentlist = std.readlines()
examlist = exm.readlines()

std.close()
exm.close()
```

har indlæst filerne og gemmer dem.

Herefter opretter jeg tre dictionaries som indeholder student id, kurser

```{python}
dictNames = {}
dictCourses = {}
dictGrades = {}
```

Så opretter vi et loop og siger hvad filerne består af. 

 

```{python}
for row in studentlist:
  student_id, name, adress = row.split(";")
  dictNames[student_id] = name
```

```{python}
print(dictNames)
```

 
 så tilføjer man default at defautl værider er nu
 
```{python}
for student_id in dictNames:
  dictCourses[student_id] = 0
  dictGrades[student_id] = 0
```
 
opret dictCourses hvor keu

```{python}
for row in examlist:
  student_id, course_name, grade = row.split(";")
  dictCourses[student_id] += 1
  dictGrades[student_id] += int(grade)
```

```{python}
print(f'{"Student id"}')
print(f'{"=" * 44}')
for key in dictNames:
  print(f'{key: < 10} {dictNames.get(key)}') 
```

Det virker ikke for dig.



### Exercise 13.4 (subset sum)

In this exercise we consider the subset sum problem. Write a function subset_sum(x, L) that as input takes a value x and a list of values L. The function should return a subset L_ of L where sum(L_)==x if such a set L_ exists, otherwise None should be returned.
Example:

> print(subset_sum(12, [2, 3, 8, 11, -1]))
[2, 11, -1]
> print(subset_sum(6, [2, 3, 8, 11, -1]))
None
The subset sum is known to be a "computionally hard" problem that essentially only can be solved by considering all 2|L| possible subsets of the input list L.

Hint. Write a recursive function that generates all possible subsets, and raise an exception (ideally user defined) during the recursion when the first solution has been found. Do not generate an explicit list of all subsets, since this will quickly lead to MemoryError exceptions.


```{python}
class SolutionFound(Exception):
  pass

def subset_sum(x, L):
  
  # rekursiv funktion
  def solution(x, L_):
    if sum(L_) == x:
      raise SolutionFound(L_)
    else:
      for n in range(len(L_)):
        solution(x, L_[0:n] + L_[n+1:])
  try:
    solution(x, L)
  except SolutionFound as sol:
    return sol.args[0] # retuner løsningen. 
  else:
    return None
```

```{python}
print(subset_sum(12, [2, 3, 8, 11, -1]))
print(subset_sum(6, [2, 3, 8, 11, -1]))
```



## Lecture 14 (Documentation, testing and debugging)

### Exercise 14.1 - handin 7 (convex hull)'


Use the function random from the module random to generate random numbers in the range [0,1), i.e. the interval from zero to one, including zero but excluding 1.

```{python}

class NotOne(Exception):
  def __init__(self, n):
    self.msg = '1 må ikke være med' + str(a)+'derfor trækkes 0.01 fra.'
    

def random_points(n):
  x_coordinate = []
  y_coordinate = []
  for i in range(0,n):
    x = ra.random()
    y = ra.random()
    x_coordinate.append(x)
    y_coordinate.append(y)
    try:
      if x_coordinate == 1:
        raise NotOne(x_coordinate)
      return [x for x in x_coordinate]
    except NotOne as e:
      print(e.msg)
      return 0

random_points(5)
```

```{python}
items = [(0, 1), (2, 3)]

a = [(0, 1), (2, 3)]
[4 if x == 0 else x for x in a]

for n, i in enumerate(a):
 if i == 1:
    a[n] = 10
a
```

## a)

```{python}
import random as ra
def random_points(n):
  x_coordinate = []
  y_coordinate = []
  not_one = 1
  for i in range(0,n):
    x = ra.random()
    y = ra.random()
    x_coordinate.append(x)
    y_coordinate.append(y)
  x_coordinate = [0.99 if x == 1 else x for x in x_coordinate]
  y_coordinate = [0.99 if x == 1 else x for x in y_coordinate]
  return [[x,y] for x,y in zip(x_coordinate, y_coordinate)]
#
#[(x,y) for x,y in zip(x_coordinate, y_coordinate)]

random_points(5)
```

## b)

```{python}
import matplotlib.pyplot as plt
plt.plot([0, 0.25, 1], [0, 1, 0.5], "r-")
plt.plot([0.25, 0.5, 1.5, 1], [0.5, 1.0, 0.5, 0], "go")
plt.show()
```






## c) 

```{python}
import functools
def convex_hull_graham(points):
    TURN_LEFT, TURN_RIGHT, TURN_NONE = (1, -1, 0)
    def cmp(a, b):
        return (a > b) - (a < b)
    def turn(p, q, r):
        return cmp((q[0] - p[0])*(r[1] - p[1]) - (r[0] - p[0])*(q[1] - p[1]), 0)
    def _keep_left(hull, r):
        while len(hull) > 1 and turn(hull[-2], hull[-1], r) != TURN_LEFT:
            hull.pop()
        if not len(hull) or hull[-1] != r:
            hull.append(r)
        return hull
    points = sorted(points)
    l = functools.reduce(_keep_left, points, [])
    u = functools.reduce(_keep_left, reversed(points), [])
    return l.extend(u[i] for i in range(1, len(u) - 1)) or l
```


## d) 


