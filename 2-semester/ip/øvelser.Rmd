---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
```

# Lecture 9 [Recursion and iteration]

## Exercise 9.1 (bitonic minimum)

We call a list L=[x1, ..., xn] bitonic, if there exists a k, 1<k<n, such that x1 > x2 > ··· > xk-1 > xk < xk+1 < ··· < xn, i.e. xk is the minimum of the list. Write a method bitonic_min that given a list, returns the minimum of the list. Your implementation should use binary search (i.e. you cannot use the Python builtin min function).
Example: bitonic_min([10,7,4,2,3,5,9,11]) should return 2.

```{python}
def bitonic_min(x):
  minimum = x[0]
  for i in x[1:]:
    if i < minimum:
      minimum = i
  return minimum
print("Output af opgave 9.1 :", bitonic_min([10,7,4,2,3,5,9,11]) )
```

## Exercise 9.2 (print tree)

Assume we represent a tree by a recursive tuple, consisting of the name of the root followed by one recursive tuple for each of the children. Note that all nodes have a label (not only the leaves), and that a node with k children is represented by a tuple of length k+1. Write a program that prints the tree with one label per line and with appropriate indentation, like below.
Example: ('root', ('node 1',), ('node 2', ('node 2.1',), ('node 2.2',)), ('node 3',)) should be printed as

--root
  |--node 1
  |--node 2
  |  |--node 2.1
  |  |--node 2.2
  |--node 3
Hint. Write a recursive method and pass a string as an argument with the prefix to be printed in front of all lines generated by the recursive call.

```{python}
test = ('root', ('node 1'))
type(test)


```



## Exercise 9.3 (maze path)
In this exercise you should code a recursive maze solver, that does a recursive search for the path from "A" to "B" in a rectangular maze. The program should read from input a maze represented by first a single line containing two numbers, the number of rows n and columns m of the maze, followed by n rows each containing a string of length m representing the maze, where "#" is a blocked cell, "A" denotes the start cell, "B" the end cell, and "." a free cell ("A" and "B" are also free cells). Given a free cell one can move to an adjacent free cell horizontally and vertically but not diagonally. An example input:

11 19
#######A###########
#.......#.#...#...#
#.###.###...#.#.#.#
#...#.....#.#...#.#
#.#.###.#.#.#.###.#
#.#.....#...#.#...#
#.###########.#.#.#
#.#.#.....#...#.#.#
#.#.#####.#####.#.#
#.........#.....#.#
###############B###
The program should output the string "no path" if there exist no path from A to B in the maze. If there exists a path, a solution should be printed with "x" marking the path from A to B. A possible solution to the above maze is:

#######A###########
#....xxx#.#xxx#xxx#
#.###x###xxx#x#x#x#
#...#xxxxx#.#xxx#x#
#.#.###.#.#.#.###x#
#.#.....#...#.#xxx#
#.###########.#x#.#
#.#.#.....#...#x#.#
#.#.#####.#####x#.#
#.........#....x#.#
###############B###
Note: In the lecture the solution only identified if there was a path from A to B.
Hint: One solution is to modify the solution from the lecture, and only make recursive calls when a solution has not been found yet, and to update the maze before returning from a recursive call. Use print('\n'.join(maze)) to print the maze.


## Exercise 9.4* (deepcopy)
In this exercise you should implement your own version of the deepcopy operation from the module copy for lists. Recall that when copying a list L using L.copy(), only a copy of the list will be created. The new list will point to the same elements as L, which might cause unexpected behaviour when these are mutable structures, like recursive lists. The operation copy.deepcopy also makes a recursive copy of such recursive lists.

The difference is illustrated by the following code:

import copy
L1 = [[1], [2]]
L2 = L1.copy()
L3 = copy.deepcopy(L1)
L1[0][0] = 3
print(f'{L1=} {L2=} {L3=}')
that prints

L1=[[3], [2]] L2=[[3], [2]] L3=[[1], [2]]
Your task is to implement your own function deepcopy that creates such a recursive deep copy of recursive lists.

Hint: Recall that the same list can be refered to multiple times, and that there can be cyclic references among the lists, like in the following example.

L = [[1], [2], [3]]
L[2] = L
To handle the copying of such recursive structures it is important to know that each list L has a unique id id(L). E.g.
print(f'{L=} {id(L)=} {id(L[0])=} {id(L[1])=} {id(L[2])=}')
could print
L=[[1], [2], [...]] id(L)=2373651524288 id(L[0])=2373623114048 id(L[1])=2373623104832 id(L[2])=2373651524288
Note that L and L[2] have identical ids, since they refer to the same list.

Example:

L1 = [[1], [2], [3]]
L2 = deepcopy(L1)
L1[1] = L1[0]
L1[2][0] = L1
L3 = deepcopy(L1)
L3[0][0] = 7
print(f'{L1=} {L2=} {L3=}')
should print
L1=[[1], [1], [[...]]] L2=[[1], [2], [3]] L3=[[7], [7], [[...]]]