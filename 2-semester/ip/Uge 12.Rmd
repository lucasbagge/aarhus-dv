---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
```


## decorators in python

- nu kommer en mere videnskablig anvendelse
- decorators er anvendt for python. 
- syntastisk sukker kaldes det. 
- decorator tager en funktion og bruger den funktion som input og derved får man en ny funktion. 
- den nederste decorator anvendelse først. 

```{python}
def f(x):
  return 3 * x
```

```{python}
f(7)
```

```{python}
l = lambda x: 4 * x
l(5)
```

```{python}
def g(f, x):
  return f(x) + 1
```

```{python}
g(f, 7)
```

- funktionen overføres

```{python}
g(l, 7)
```

- decorator går netop ud på at tage en funktion og retuner en ny funktion.

```{python}
def h(f):
  return lambda x: f(x) + 1
```

- tag oprindelig funktion og ændre det og læg 1 til

```{python}
h(l) # ny funktion.
```
```{python}
k = h(l)

k(6)
```

- lav end ecorator

```{python}
def plus_one(x):
  return x + 1

def square(x):
  return x**2

def cube(x):
  return x**3

# skal kaldes plus når vi har cube.
def cube(x):
  return plus_one(x ** 3)

# ser det som en hjælper funktion til
```

```{python}
# andet eksempel med lambda
square_orginal = square
square = lambda: x: plus_one(square_orginal(x))
square(5)
```

```{python}
def plus(x):
  return x + 1

def plus_one_decorator(f):
  return lambda x: plus_one(f(x))

square = plus_one_decorator(square)

print(square(5))
```

- Nyt eksempel igen

```{python}
# @ decorator på en funktion tager funktionen og smider en ny funktion ud. 
@plus_one_decorator
def square(x):
  return x ** 2
square(5)

```

```{python}
def plus_one_decorator(f):
  def plus_one(x):
    return f(x) + 1
  return plus_one

@plus_one_decorator
def square(x):
  return x ** 2
square(5)
```

- ovenstående kalder funktionen og anvender den på lokal funktion. 
- Det ses som den korrekte metode.

- videre med eksempel

```{python}
@plus_one_decorator
@plus_one_decorator
def square(x):
  return x**2

square(5)
```

- når vi kalder decorator igen så lægges der flere til.

- med () kalder man decorator

- wrapper bruges som eksempel på decorator.

```{python}
def run_twice(f):
  def wrapper(*args):
    f(*args)
    f(*args)
  return wrapper

@run_twice
def helle_world():
  print("hell")
  
helle_world()
```

- args holder argumenter i en tuple. 

- eksempel til at se om argumenter er korrekt.

```{python}
def integer_sum(*args):
  assert all([isinstance(x, int) for x in args]), \
              "all arguments most be int"
  return sum(args)

integer_sum(1,2,3)
```

- man kan dele ovenstående op i en decorator. 
- definitin kan være kompliceret men skal være let at anvende dem. 
-  man kan decorator der bruges som argumenter i funktion.

```{python}
# se hvad funktionen hedder. 
f.__name__
```
- Lad os se på indbygget decorator.
- @property

```{python}
class Ractangle:
  def __init__(self, width, height):
    self.width = width
    self.height = height
    
  @property
  def area(self):
    return self.width * self.height
    
r = Ractangle(3, 4)
# med property kan vi fjerne parentes
print(r.area)
```

- gør vi får ejerskab på funktionen. 

- klasse decorator kan man også se.

- data classes ser på namedtuple.
- fra dataclasses har de funktionen dataclass hvor man tilføjer en metode til klassen.



```{python}
from dataclasses import dataclass

@dataclass

class
```


- functools findes og til decorator. 


## dynamisk programmering

- teknik hvor man løser rekursiv. Man regner de samme ting flere gang.

```{python}
def binomial(n, k):
  if k == 0 or k ==n:
    return 1
  return binomial(n-1, k) + binomial(n-1, k-1)
binomial(7,5)
```

- i dynamisk programmering vil vi undgå at regne ting flere gange.
- Husk svar man kender og kendes under **memoization**. 
- tilføj en dic

```{python}
answers = {}
def binomial(n, k):
  if (n,k) not in answers:
    if k == 0 or k ==n:
      answer = 1
    else:
      answer = binomial(n-1, k) + binomial(n-1, k-1)
    answers[(n,k)] = answer # tabel til at husek tabellen
  return answers[(n,k)]
binomial(7,5)
```

- den er slet ikke så stor som før.  

```{python}
answers
```

- Hvor stor skal den tabel være? n*k, alle de rekursive kald de bliver n mindre.

- man kan bruge decorators.@memoize til at bruge til at effektivserer koden. 

```{python}
def memoize(f):
  answers = {}
  
  def wrapper(*args):
    if args not in answers:
      answers[args] = f(*args)
    return answers[args]
  return wrapper
```

```{python}
@memoize

def binomial(n, k):
  if k == 0 or k ==n:
    return 1
  else:
    return binomial(n-1, k) + binomial(n-1, k-1)
binomial(7,5)
```

- args skal være nøgle i dict. den skal være mutable. Men gælder ikke for list.
- lave en trace funktion til at se hvor fork den er blevet.

- @lru_cache i functools er det samme som memoize.

- et andet eksemple er subset sum using dynamisk problem. 
- s(v, k-1) or s(v - L[k - 1], k-1) er den rekursive provess vi skal implementere.

```{python}
def subset_sum(x, L):
  @memoize
  def solve(value, k):
    if k == 0:
      return value == 0
    return solve(value, k-1) or solve(value - L[k-1], k-1)
  return solve(x, len(L))

subset_sum(11, [2,3,8,11,-1])
```

- skal have index så ikke true.

- Et andet eksempel som er sværer **knapsack**, V(c, k - 1) og max{V[c, k-1], value[k-1] + V(c - volume[k-1], k-1)}



```{python}

```






