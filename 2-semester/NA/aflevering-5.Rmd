---
title: "Aflevering 5"
subtitle: "Lucas Bagge"
output: pdf_document
---


* kommentar til *plot, det betyder den folder listen ud således vi plotter alle elementer.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
```

![](alf.5a.png){width="567"}

### a)

I den første del af opgaven skal vi tage de angivende funktioner:

$$
(3 cos(t), sin(2t)), \text{for } 0 \le t \le 2\pi
$$

#### Moduler

Hertil vil jeg hente \`numpy\` og matplotlib modulerne.

```{python}
import numpy as np
import matplotlib.pyplot as plt
```

Nu kan jeg således danne vores punkter til figuren.

```{python}
t = np.linspace(0, 2*np.pi, 1000)
y_1 = 3 * np.cos(t)
y_2 = np.sin(2*t)
eight = np.array([y_1, y_2])
```

Herefter kan vi plotte det.

```{python}
fig, ax = plt.subplots()
ax.set_aspect('equal')
ax.plot(*eight)
plt.show()
```

![](alf.5b.png)

### b) 

Allerede først vil jeg angive de to funktioner som er oplyst i opgave teksten:

```{python}
rng = np.random.default_rng()
theta = rng.uniform(np.pi / 10, (9 * np.pi) / 10)
```

Herefter definerer jeg min rotationsmatrice:

```{python}
c = np.cos(theta)
s = np.sin(theta)
R = np.array([[c * theta, -s  * theta],\
              [s  * theta, c  * theta]])

```


```{python}
rotated = R @ eight
fig, ax = plt.subplots()
ax.set_aspect('equal')
ax.plot(*(rotated))

plt.show()
```

- eight og eihgt_R er begge (2, 100) matricer hvordan regnes vinklen mellem dem?

## c)

![](alf.5c.png)
Dan den matricen angivet i opgave beskrivelsen:

- går opgaven bare ud på at lave A ud fra normal og plotte den?
- Jeg har fulgt hvordan Andrew har gjort i en af hans noter. 

```{python}
noise = rng.normal(0.0, 0.1, (2, 1000))
A = rotated + noise 
fig, ax = plt.subplots()
ax.set_aspect('equal')
ax.plot(*A, 'o', markersize = 2)
plt.show()
```


## d)

![](alf.5d.png)

- Jeg vil gøre følgende, men hvordan sikrer jeg at middelværdien i den nye
  matrice er 0 ?

```{python}
B = np.vstack([A[0] - np.mean(A[0]), A[1] - np.mean(A[1])])
```

```{python}
fig, ax = plt.subplots()
ax.scatter (*B, color = "blue")
plt.show()
```


## e)

![](alf.5e.png)

SVD er en matrix dekomponering metode der reducere en matrice i tre komponenter for senre at gøre udregninger til andre matricer simpler. 

$U$ er en m x m matic, $\Sigma$ er en m x n diagonal matrix og $V^T$ er den transponerede af en n x n matrix.

De diagonale værdier i $\Sigma$ kendes som singulærværdierne af den orginale matrice. Kolonnerne af U kaldes venstre-singulær vektor af den orginale matrix og kolonnen af V kaldes højre singulær vektor af A.


For vores B matrices komponenter er givet som følgende:

```{python}
u, s, vt = np.linalg.svd(B, full_matrices = False)

print("Dimensioner af vores singulærværdier: \n",u.shape, s.shape, vt.shape)
print("Værdien af u: \n", u)
print("Værdien af s, som er vores singulærværdier: \n", s)
print("Værdien af vt: \n", vt)
```


## f)

se på 10.3.2 bemærk at værdier kan vi e hvilken er størst, og se på de retnings
vektor i matricen. i matricen U får vi to vektor ud og tegn dem ind i vores.
Hvilken retning giver mest varians. Hvilken retning er figuren længst. 
 
```{python}
n = 1000
scale = 2/np.sqrt(n)
tscale = 1.2*scale
origo = np.zeros((2,1))
fig, ax = plt.subplots()
ax.set_aspect('equal')
ax.scatter (*B, color = "blue")
ax.plot(*np.hstack([origo, u[:,[0]]*s[0]]))
ax.text(*u[:, [0]]*s[0]*tscale, 's0*u0', color='blue')
ax.plot(*np.hstack([origo, u[:,[1]]*s[1]]))
ax.text(*u[:, [1]]*s[1]*tscale, 's1*u1', color='red')
plt.ylim([-2.0,2.0])
plt.xlim([-3.0, 3.0])
plt.show()
```

Når vi ser på vores singulærværdier:

```{python}
print("Singulærværdier: \n", s)
```

Her kan vi se at 43 er støsrt som er vores s[0].

Denne singulærværdi har venstesingulærvektor som er den første føjle af u. Vores figur foroven viser at det således er de venstresingulærvektorer giver retningerne hvor variationen af punkterne er størst.


![](alf.5fg.png)

## g) 

```{python}

```

